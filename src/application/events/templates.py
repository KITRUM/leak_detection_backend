from collections import defaultdict
from functools import partial

from src.application.data_lake import data_lake
from src.domain.events.sensors import Event as SensorEvent
from src.domain.events.templates import (
    Event,
    EventType,
    EventUncommited,
    services,
)
from src.infrastructure.errors.base import BaseError

TEMPLATES_CRITICAL_EVENT: dict[int, dict[int, bool | None]] = defaultdict(
    partial(defaultdict, lambda: None)  # type: ignore[arg-type]
)
# NOTE: The overview of the data structure.
#       17: tempalte id
#       12,15: sensor ids
#       None: no events yet
#       False: last event is OK
#       True: last event is CRITICAL
#       ...
#       {
#           17: {
#               12: False,
#               15: None,
#           }
#       }


async def process(sensor_event: SensorEvent):
    """This function represents the engine of producing events
    that are related to the specific template.

    If at least one sensor does have the critical rate
    the whole template generates the CRITICAL event.

    ðŸ‘½ Description:
    Let's say the template has 4 sensors.

    The default critical rate value of each sensor is `false`.

    If the CRITICAL sensor's event is comming the rate gets into `true`.
    Once the OK event comes, then the `false` sets
    to the TEMPLATES_CRITICAL_EVENTS[template_id][sensor_id]

    If ANY from TEMPLATES_CRITICAL_EVENTS[template_id] is `true`,
    the CRITICAL event is generated by the template for this sensor event.

    In case a sensor has a None value we assume it as OK event.
    This state is needed since the case of first OK event should be sent.

    Once ALL from TEMPLATES_CRITICAL_EVENTS[template_id] get to `false` BACK,
    the OK event is generated by the template for this sensor event.
    """

    sensor = sensor_event.sensor
    last_sensor_event_is_critical: bool | None = TEMPLATES_CRITICAL_EVENT[
        sensor.template_id
    ][sensor.id]

    if all(
        [
            item is None
            for item in TEMPLATES_CRITICAL_EVENT[sensor.template_id].values()
        ]
    ):
        # `None` if any of sensor is `None`
        last_template_event_is_critical: bool | None = None
    elif any(TEMPLATES_CRITICAL_EVENT[sensor.template_id].values()):
        # `true` if all sensors are `true`
        last_template_event_is_critical = True
    else:
        # `false` if any sensor is `true`
        last_template_event_is_critical = False

    # TODO: Check this feature. Not working properly on status change
    match last_template_event_is_critical, last_sensor_event_is_critical:
        case None, None:
            TEMPLATES_CRITICAL_EVENT[sensor.template_id][sensor.id] = False
            type_ = EventType.OK
        case None, False:
            TEMPLATES_CRITICAL_EVENT[sensor.template_id][sensor.id] = False
            type_ = EventType.OK
        case True, False:
            TEMPLATES_CRITICAL_EVENT[sensor.template_id][sensor.id] = False
            type_ = EventType.OK
        case False, False:
            TEMPLATES_CRITICAL_EVENT[sensor.template_id][sensor.id] = False
            type_ = EventType.OK
        case None, True:
            TEMPLATES_CRITICAL_EVENT[sensor.template_id][sensor.id] = True
            type_ = EventType.CRITICAL
        case False, True:
            TEMPLATES_CRITICAL_EVENT[sensor.template_id][sensor.id] = True
            type_ = EventType.CRITICAL
        case True, True:
            TEMPLATES_CRITICAL_EVENT[sensor.template_id][sensor.id] = True
            type_ = EventType.CRITICAL
        case _:
            raise BaseError(
                message="Unhandled combination for template events"
            )

    current_template_event_is_critical: bool = any(
        TEMPLATES_CRITICAL_EVENT[sensor.template_id].values()
    )

    if current_template_event_is_critical is last_template_event_is_critical:
        # If the event rate of the template did not change, then skip
        return

    event: Event = await services.create(
        EventUncommited(type=type_, template_id=sensor.template_id)
    )

    # Update the data lake
    data_lake.events_by_template[sensor.template_id].storage.append(event)
